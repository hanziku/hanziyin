## 數據結構說明

部件檢字必須提供兩大訊息，一是字由那些構件組成，二是一個或多個構件可以組成那些字。

* 明=日月 , 晴=日青       稱為拆分表
* 日=昌晴明晶       稱為孳乳表

部件檢字遍歷拆分表，比較耗時，因為每個拆分都必須過一遍才知道構件在該字存不存在，
也就是時間複雜度是固定的 O

而孳乳表讓「部件檢字」得以快速實現，即使是構字能力最較強的部件，它的孳乳數佔總字集也不到 10%，大部份都不到百分之一甚至千分之一，時間複雜度可以降  2~3 個數量級。

但（乳表只能回報構件組成了那些字，無法提供某字的構件拆分信息。

構件是漢字的核心信息，空間越省越好，由於Unicode 按部首筆劃排列的特性，如果將拆分表按Unicode Codepoint 排列，發現第一個構件經常是一樣的，因此我們可以RLE壓縮字串的方式來儲存。

用字串的 index 表示 Unicode 的codePoint，而由於每個字最多11個構件，所以只需要11個字符串。(見 hz_data idsarr)

第一和第二個字符串是「滿的」，第三個之後會快速變得稀疏，RLE的壓縮效果很明顯。

部件搜尋時，只需要遍歷11個字符串(每個串最長一百多KB)，這樣比遍歷有八萬個字符串的拆分表快得多。

此外，由於idsarr也提供了構件在字位置。因此可以得到完全的構件序列（提供比拆分表慢，但從時間和空間複雜度的角度很值得）。

經過這樣的設計，可同時提供快速部件檢字和拆分序列的數據結構只要不到600KB，如果用原先的方式，八萬字集的拆分表加上孳乳表，至少得 2MB~3MB。

## idsarr

最關鍵也是最大的的結構，提供兩大信息：字的構件序，以及構件產生的孳乳。

hz_data.js idsarr是一個 11 個長字串的陣列。每個字串position 為Unicode codepoint ，其值為構件。沒有構件補以 空格。
idsarr[0]  中  ：「亻31亼亻37亼亻47」，表示有31個字以「亻」為第一個構件，然後是以「亼」為第一構件，然後是37個字以「亻」為第一個。
idsarr[10]=" 22801㔾 11555夊 102111尸 10987𡘜 10682② 1218丨 785木 7638儿 18275
表示頭22801個字都沒有第十個構件(空白)，之後的那個字以「㔾」為第十構件，然後11555個字沒有第十構件，之後的那個字以「夊」為第十構件……

通常一個字有兩個構件。idsarr[0] 是全部字的第一個構件，比idarr[1]短，因為Unicode 按部首排列，第一個構件重覆率高可壓縮(80KB)

 idsarr[1] 是的第二個構件，這是最長的，因為都有第二構件，而又無法壓縮。(160KB左右) ，其後為48KB , 25KB,10KB,4KB ...
 
idsarr[2]之後很稀疏（三構件的字較少），有大量重覆的空格。

因為尋找不必隨機讀取，在內存中不必展開。用forEachRLE 遍歷以獲取每個元件。